#!/usr/bin/env node
/**
 * Mike Carifio <mike@carif.io>
 *
 *     Scaffolding stolen from http://shapeshed.com/command-line-utilities-with-nodejs/
 */

var jsonld = require('jsonld'); // https://github.com/digitalbazaar/jsonld.js/
var decomment = require('decomment');
var fs = require('fs');
var util = require('util');
var log4js = require('log4js'); // https://github.com/nomiddlename/log4js-node
var logger = log4js.getLogger(); // TODO mike@carif.io: scope?
var program = require('commander'); // https://www.npmjs.com/package/commander

// TODO mike@carif.io: add template expansion. Already in node?
// var template = require('some template thing')

// TODO mike@carif.io: turn this into a node module
// var translate = require('translate');

// TODO mike@carif.io: run nodejs command line app from within Intellij WebStorm?






/**
 * Deep clone of input object o for any type. Protect against modification of object o.
 * @param {object} o - input object
 * @returns {object} - copy of o, same contents different memory
 */

function clone(o) {
    return JSON.parse(JSON.stringify(o));
}


/**
 * Slurp returns the contents of filename as a utf8 string.
 * @param {string} filename
 * @returns {string}
 *
 * TODO mike@carif.io: Does node|js have a pathname repr?
 */
function slurp(filename) {
    // TODO mike@carif.io: async this eventually
    // https://nodejs.org/api/fs.html#fs_fs_readfilesync_file_options
    return fs.readFileSync(filename, "utf8");
}




/**
 * Load a file and return it as a JSON object. Remove comments.
 * @param {string} filename
 * @returns {object} - JSON object from filename
 */

function load(filename) {
    var s = slurp(filename);
    var j = decomment(s);
    // logger.debug(j);
    return JSON.parse(j);
}





/**
 * Translate a demographics object to the target format.
 * @param {object} chcs_demographics - input object to extract demographics (patient data)
 * @returns {string|object} -  string if turtle, object if fhir
 */

function translate_demographics(chcs_demographics) {
    return {tbs: true};
}



function turtle_emitter(stanza) {
    logger.debug("turtle emit for '%s'", stanza);
}

function fihr_emitter(stanza) {
    logger.debug("firh emit for '%s'", stanza);
}


function translate_context(context) {
    logger.warn("translate_context needs implementation");
    return context;
}


// TODO: underscore? utility library?
function isList(o) { return o.constructor == Array; }


// TODO mike@carif.io: write one of these per recognized chcss type
// Embeds knowledge of the chcss type encoding. Kinda sucks.
function isPerson(o) {
    return o['type'] && o['type'].match(/chcss:\s*2\s*$/);
}


/**
 * Translate an entire chcs @graph object to either turtle or fhir depending on the emitter.
 *
 * @param {object} graph - The jsonld generated by an 'all' report in LDR.
 * @param {function} emitter - a function that is passed to each node in the chcs_all object. It "knows" how to emit
 *   turtle or fhir.
 * @returns {list[object]} - the turtle or fhir representing chcs_all
 *
 */

function translate_graph(graph, emitter) {
    if (!emitter) emitter = turtle_emitter;

    // var result = clone(chcs_all);
    var result = [];

    // translate result in place and then return it
    if (isList(graph)) {
        result.push(graph.map(translate_graph));
    } else if (isPerson(graph)) {
            result.push(translate_demographics(graph));
    } else {
        result.push(graph);
    }

    return result;
}





/**
 * Pretty print a JSON object.
 * @param json
 */

function pretty_print(json) {
    return JSON.stringify(json, null, 2);
}




/**
 * Process the chcs jsonld file.
 * @param {string} filename
 * @returns {(string|object)}
 */

function process_file(filename) {

    try {

        logger.info('process ' + filename);
        if (!filename.match(/\.jsonld$/))
            logger.warn(util.format("Expected filename '%s' to end with '.jsonld'. Did not.", filename));

        // minify and load filename into an object; minify removes comments
        var chcs = load(filename);

        // Translate the object from chcs jsonld to fhir jsonld
        var result = {
            "@context": translate_context(chcs["@context"]),
            "@graph": translate_graph(chcs["@graph"]),
        };


        // See the result
        logger.debug(pretty_print(result));

        return result;

    } catch (err) {
        logger.error(err);
    }

}


/**
 * Read the chcs from stdin and process that.
 * @param {Readable Stream} s - usually stdin or something directed toward it.
 * @returns {(string|object)} -- turtle string or json fhir
 */
function process_stream(s) {
    logger.error("tbs");
}



/**
 * Exact the program version from package.json if you can find package.json
 * @param default_version
 * @returns {*}
 */
function get_version(default_version) {
    var result = default_version;
    try {
        result = load("../package.json").version;
    } finally {
        return result;
    }
}

// https://github.com/tj/commander.js/
program
    .version(get_version('0.0.1'))
    .option('-v, --verbose', 'verbose')
    .option('-h, --help', 'usage')
    .option('--level [level]', 'log level usage', 'DEBUG')
    .option('--log [log_file]', 'log file')
    .parse(process.argv);

logger.setLevel(program.level);


// TODO mcarifio: must be a way to just process these all as streams?
if (program.args.length > 0) {
    // process urls (files) from the command line
    program.args.forEach(process_file);
} else {
    // process stdin
    process_stream(process.stdin);
}




