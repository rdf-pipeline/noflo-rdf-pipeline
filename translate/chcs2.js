#!/usr/bin/env node

'use strict';

/**
 * Mike Carifio <mike@carif.io>
 *
 *     Scaffolding stolen from http://shapeshed.com/command-line-utilities-with-nodejs/
 *     Need it to run this file in webstorm under the debugger, a productivity boast.
 */

var jsonld = require('jsonld'); // https://github.com/digitalbazaar/jsonld.js/
var decomment = require('decomment');
var fs = require('fs');
var util = require('util');
var log4js = require('log4js'); // https://github.com/nomiddlename/log4js-node
var logger = log4js.getLogger(); // TODO mike@carif.io: scope?
var program = require('commander'); // https://www.npmjs.com/package/commander
var _ = require('underscore');

// TODO mike@carif.io: add template expansion. Already in node?
// var template = require('some template thing')

// TODO mike@carif.io: turn this into a node module
// var translate = require('translate');




// Long sequence of is_chcs*(candidate) => boolean. These predicates tell you that you have a chcs object of a
// certain type. They all work by looking for a type tag and matching a regular expression.

/**
 *
 * @param {object} candidate -- candidate to test
 * @returns {boolean}
 */


/**
 * Returns true iff object 'candidate' is a chcs type matched by 'regular_expression' without regard to whitespace.
 * @param {regex} regular_expression - how to match the 'type' tag
 * @returns {Function} - typically assigned to a memorable function name, e.g. is_chcsPerson.
 */
function is_chcsType(candidate, regular_expression) {
    return typeof candidate == 'object' && candidate['type'] && candidate['type'].match(regular_expression);
}

function is_chcsPerson(candidate) {
    return is_chcsType(candidate, /chcss:\s*2\s*$/);
}


/**
 * Translate an entire chcs @graph object depending on the translate function.
 * Assumes a 1-1 translation strategy.
 * TODO mike@carif.io: 1-1 won't hold up. But let's see how far it goes.
 *
 * @param {list[object]} graph - The jsonld generated by an 'all' report in LDR.
 * @param {Function(document) => boolean} isType - a predicate of one argument, a document, that returns true iff the document
 *        is the right chcs type.
 * @param {Function(document) => object} translate
 * @returns {list[object]} - the turtle or fhir representing the report kind e.g. 'medsop' or 'medinp'
 */

function translate_graph_1to1(graph, isType, translate) {
    // traverse the graph either
    if (_.isArray(graph)) {
        // http://cryto.net/~joepie91/blog/2015/05/04/functional-programming-in-javascript-map-filter-reduce/
        return graph.filter(isType).map(translate);
    } else if (isType(g)) {
        return translate(g);
    } else {
        return null;
    }
}


/**
 * Returns all keys of all objects in a recursive tree of objects as a "set" of strings.
 * The set is actually represented as an Array, but with the previso that each string occurs once.
 * @param {Array|Object|scalar} tree - the tree of key/value pairs
 * @returns {Array[String]} - set of keys occurring in tree
 */

function all_keys(tree) {
    if (_.isArray(tree)) {
        return tree.map(all_keys).reduce(function (previous, current) { return _.union(previous, current); }, []);
    } else if (_.isObject(tree)) {
        return _.keys(tree);
    } else {
        return [];
    }
}




function lift(graph) {
    //"use strict";
    logger.warn("lift tbs");
}

/**
 * TBS Translate an entire chcs @graph object depending on the translate function.
 * Assumes a 1-1 translation strategy.
 *
 * @param {list[object]} graph - The jsonld generated by an 'all' report in LDR.
 * @param {Function(list[document]) => object} lift - lifts values out of graph to be passed to translate
 * @param {Function(object) => list} translate - translates graph after lifting out the arguments
 * @returns {list[object]} - the turtle or fhir representing the report kind e.g. 'medsop' or 'medinp'
 */

function translate_graph(graph, lift, translate) {
    logger.error("not yet implemented")
    var args = lift(graph); //
    var l = Object.keys(args);
    args.length = l; // you can apply a dict that has a length and parameters by position, e.g. {'length':2, 0:1, 1:2}
    return [ translate.apply(null, args) ];
}





/**
 * Lift the demographics data out of a chcs object into an "array-like" object.
 * Keys are indexed by position. The result is suitable for javascript function apply.
 * @param {object} chcs_patient_object - input chcs object to extract demographics (patient data)
 * @returns {Array-like object} - {length: 3, 0: name, 1: gender, 2: dob }
 */

// Not sure this is useful yet.
function lift_demographics(chcs_patient_object) {
    var name = chcs_patient_object['label'];
    var gender = chcs_patient_object['sex-2'].label;
    var dob = chcs_patient_object['dob-2'].value;
    // transforms here if needed
    var result = {0: name, 1: gender, 2: dob};
    result.length = Object.keys(result).length;
    return result;
}

/**
 * Translate chcs_date string in format yy(yy)?-mm-dd to fhir format mm-dd-yyyy.
 * @param {string} chcs_date - yy(yy)?-mm-dd
 * @returns {string} - mm-dd-yyyy
 */
function fhir_date(chcs_date) {
    var m = chcs_date.match(/(\d{2,4})-(\d{2})-(\d{2})/);
    if (m) {
        var year = m[1]; // year group in re
        if (year.length == 2) year = '19' + year; // fix up yy
        var month = m[2]; // month group in re
        var day = m[3]; // day group in re

        return day + '-' + month + '-' + year;
    }
    throw "Bad chcs date: '" + chcs_date + "'"; // assume stacktrace
}

/**
 * Translate a chcs name format 'LAST, FIRST MI TITLE' to fhir HumanName
 * http://hl7-fhir.github.io/datatypes.html#HumanName
 *
 * @param chcs_name
 * @returns {{resourceType: string, use: string}}
 *
 * TODO: has to be a better way to write these things. Don't know how...
 */
function fhir_HumanName(chcs_name) {

    var parts = chcs_name.split(/\s*,\s*/); // last, first mi title; split off the last name

    // Name should have had a comma in it, so there should be two parts and the second part should have contents.
    if (parts.length == 1 || parts[1].length == 0) {
        throw "Bad chcs name, expecting 'LAST, FIRST MI? TITLE?': '" + chcs_name + "'"
    }


    var after_comma = parts[1].split(/\s+/); // the second part should ahve first mi? title?

    // here: we have the various chcs parts. Assemble an fhir HumanName
    var result = {
        "resourceType": "HumanName",
        "use": "usual", // "official"?
    };

    result.family = [ parts[0] ]; // yes, all lists
    var given = [ after_comma[0] ];
    if (after_comma.length > 1) // middle initial mi
        given += ' ' + after_comma[1];
    result.given = [ given ];

    if (after_comma.length > 2) { // title
        result.prefix = [ after_comma[2] ];
    }

    return result;
}


/**
 * Turn a US social security number into a fhir identifier.
 * @param chcs_ssn
 * @returns {{use: string, type: null, system: string, assigner: string, type: null, value: *}}
 *
 * TODO: would be helpful to capture the json path from the source chcs object
 *   and put it in the result, something like 'x-source-path': "/@graph/* /type='chcss:2'/ssn-2"
 */
function fhir_identifier(chcs_ssn, chcs_dod_id) {
    var result = [];

    // ssn if it has a value
    if (chcs_ssn) {
        result.push({
            'use': 'usual',
            // 'system': "ssn://www.us.gov/",  // made up
            'assigner': 'US',
            'type': {'coding': 'chcss', 'text': chcs_ssn },
            'value': chcs_ssn
        });
    };

    // dod_id if it has a value
    if (chcs_dod_id) {
        result.push({
            'use': 'usual',
            // 'system': "dod://www.us.mil/",  // made up
            'assigner': 'US',
            'type': {'coding': 'chcss', 'text': chcs_dod_id },
            'value': chcs_dod_id
        });
    };

    return result;
}


/**
 * Translate a chcs marital status into a fhir maritalStatus(http://hl7-fhir.github.io/valueset-marital-status.html)
 * @param {string} chss_marital_status - acts as an enum
 * @returns {}
 */
function fhir_maritalStatus(chss_marital_status) {
    var uc_chss_marital_status = chss_marital_status.toUpperCase();
    var code;
    // mapping from http://hl7-fhir.github.io/v3/MaritalStatus/index.html
    // Note that you could just take the first character of chcs_marital_status,
    //  but this might change and it could introduce a bug.
    if (uc_chss_marital_status == 'SINGLE, NEVER MARRIED') {
        code = 'S';
    } else if (uc_chss_marital_status == 'MARRIED') {
        code = 'M';
    } else if (uc_chss_marital_status == 'DIVORCED') {
        code = 'D';
    } else if (uc_chss_marital_status == 'WIDOWED') {
        code = 'W';
    } else {
        throw "Bad marital status: '" + chss_marital_status + "'";
    }

    // return a "CodableConcept"
    return {'coding': code, 'text': [ chss_marital_status ] };
}



// http://hl7-fhir.github.io/datatypes.html#Address
//{
//    "line" : ["<string>"], // Street name, number, direction & P.O. Box etc.
//    "city" : "<string>", // Name of city, town etc.
//    "district" : "<string>", // District name (aka county)
//    "state" : "<string>", // Sub-unit of country (abbreviations ok)
//    "postalCode" : "<string>", // Postal code for area
//    "country" : "<string>", // Country (can be ISO 3166 3 letter code)
//    "period" : { Period } // Time period when address was/is in use
//}

function fhir_address(address) {
//    "use" : "<code>", // home | work | temp | old - purpose of this address
//    "type" : "<code>", // postal | physical | both
    var result = {
        // "resourceType" : "Address",
        // from Element: extension
        "resourceType" : "Address",
        //    "use" : "<code>", // home | work | temp | old - purpose of this address
        "type" : "postal", // postal | physical | both
        // "text" : "<string>", // Text representation of the address
        //  ... skip
    };

    var line = [];
    if (address.street1) line.push(address.street1);
    if (address.street2) line.push(address.street2);
    if (address.street3) line.push(address.street3);
    if (line.length > 0) result.line = line;

    if (address.city) result.city = city;
    if (address.county) result.district = address.county;
    if (address.state) result.state = address.state;
    if (address.country) result.country = address.country
    if (address.zip) result.postalCode = address.zip;
    return result;
}


/**
 * Translate a chcs Patient (id 'Patient-2', label 'Patient', fmDD 'fmdd:2') to its fhir analog.
 * Fields for chcs 'Patient-2' (fmdd:2) taken from mongodb collection 'schema'.
 * Fields for fhir taken from http://hl7-fhir.github.io/patient.html.
 * There are 224 Patient fields to map. Do keys in the order they actually appear in patient records,
 *   mongodb collection '2'.
 *
 * Note: chcs dates are yy(yy)?-mm-dd, fhir dates are mm-dd-yyyy. fhir_date converts chcs dates to the fhir format.
 *
 * @param chcs_patient_object
 * @returns {object} - with fhir key/values and conventions.
 *
 * TODO: log warnings? Makes the function busy.
 */
function translate_demographics_fhir(chcs_patient_object) {

    // Built result attribute by attribute. Then return it.
    var result = {
        "resourceType" : "Patient",
        //"active" : true, // Whether this patient's record is in active use
    };

    var participating_properties = [];

    // chcs ssn-2 or chcs dod_id_number-2 to fhir identifier
    // NB: dod_id_name is missing the 'name' in mongo and hence in the chcs jsonld.
    if (_.has(chcs_patient_object, 'ssn-2') || _.has(chcs_patient_object, 'dod_id_-2')) {
        // Looks like dod_id_number is usually just a repeat of ssn-2. But it might not be.
        var ssn = _.result(chcs_patient_object, 'ssn-2', null);
        var dod = _.result(chcs_patient_object, 'dod_id-2', null);
        result.identifier = fhir_identifier(ssn, dod);
        participating_properties.push('ssn-2');
        participating_properties.push('dod_id-2');
    }

    // fhir active -- skip

    // fhir name
    // chcs has both 'label' and 'name'. Try them in succession.
    // TODO: what's the diff btwn label and name?
    if (_.has(chcs_patient_object, 'name-2')) {
        // "PATIENT NAME must be entered in the form 'LAST,FIRST MI TITLE'.  The last
        // name may contain a hyphen or an apostrophe and must be followed by a comma\rand the first name.
        // The first name may contain a hyphen.  No other
        // punctuation characters are valid.  Middle initials and titles are optional.",
        // value type is string.

        // translate chcs 'last, first mi title' to {'resourceType': 'HumanName' ... }
        result.name = [ fhir_HumanName(chcs_patient_object['name-2']) ];
        participating_properties.push('name-2');
    } else {
        if (_.has(chcs_patient_object, 'label')) {
            result.name = [ fhir_HumanName(chcs_patient_object.label) ];
            participating_properties.push('label');
        }
    }

    // fhir telecon

    // fhir gender
    if (_.has(chcs_patient_object, 'sex-2')) {
        result.gender = chcs_patient_object['sex-2'].label.toLowerCase(); // chcs only encodes 'MALE' and 'FEMALE'
        participating_properties.push('sex-2')
    }

    // fhir birthDate
    if (_.has(chcs_patient_object, 'dob-2')) {
        // translate chcs date yyyy-mm-dd to fhir date mm-dd-yyyy
        result.birthDate = fhir_date(chcs_patient_object['dob-2'].value); // xsd:date, yyyy-mm-dd
        participating_properties.push('dob-2');
    }


    // fhir deceased

    // fhir address
    // Try to construct portions of an address. If you have any parts at all, convert it
    //   into a fhir address. Otherwise skip it.
    var address = {};  // intermediate address to pass into fhir_address.
    if (_.has(chcs_patient_object, 'street_address-2')) {
        address.street1 = chcs_patient_object['street_address-2'];
        participating_properties.push('street-address-2');
    }
    if (_.has(chcs_patient_object, 'street_address_2-2')) {
        address.street2 = chcs_patient_object['street_address_2-2'];
        participating_properties.push('street_address_2-2');
    }
    if (_.has(chcs_patient_object, 'street_address_3-2')) {
        address.street3 = chcs_patient_object['street_address_3-2'];
        participating_properties.push('street_address_3-2');
    }
    if (_.has(chcs_patient_object, 'city-2')) {
        address.city = chcs_patient_object['city-2'];
        participating_properties.push('city-2');
    }
    if (_.has(chcs_patient_object, 'state-2')) {
        var state_country = chcs_patient_object['city-2'].split('/');  // ME/USA
        var state = state_country[0];
        if (state_country.length > 1) address.country = state_country[1];
        participating_properties.push('state-2');
    }
    if (_.has(chcs_patient_object, 'county-2')) {
        address.county = chcs_patient_object['county'];
        participating_properties.push('county');
    }
    if (_.has(chcs_patient_object, 'zip_code-2')) {
        address.zip = chcs_patient_object['zip_code-2'];
        participating_properties.push('zip_code-2');
    }
    if (_.keys(address).length > 0) {
        result.address = [ fhir_address(address) ];
    }


    // fhir maritalStatus
    // chcs "marital_status-2" one of 'single, never married', 'married', 'divorced', 'widowed'
    //   probably all upper case
    if (_.has(chcs_patient_object, 'marital_status-2')) {
        // translate chcs date yyyy-mm-dd to fhir date mm-dd-yyyy
        result.maritalStatus = fhir_maritalStatus(chcs_patient_object['dob-2'].value);
        participating_properties.push('dob-2');
    }


    // fhir multipleBirth // twins

    // fhir photo

    // fhir contact

    // fhir animal -- skip

    // fhir communication

    // fhir careProvider

    // fhir managingOrganization -- VA

    // fhir link


    return [ result, participating_properties ];
}



//function generate_turtle_demographics(d) {
//    return {'turtle-demographics': {'name': d['label'], 'gender': d['sex-2'].label, 'dob': d['dob-2'].value}};
//}


function translate_context(context) {
    logger.warn("translate_context needs implementation");
    return context;
}









/**
 * Process the chcs jsonld file.
 * @param {string} filename
 * @returns {object}
 */

function process_file(filename) {
    try {

        logger.info('process ' + filename);
        // if (!filename.match(/\.jsonld$/))
        //    logger.warn(util.format("Expected filename '%s' to end with '.jsonld'. Did not.", filename));

        // minify and load filename into an object; minify removes comments
        var chcs = load(filename);

        // Translate the object from chcs jsonld to fhir jsonld
        //var result = {
        //    "@context": translate_context(chcs["@context"]),
        //    "@graph": translate_graph_1to1(chcs["@graph"], is_chcsPerson, translate_demographics_fhir), // Array => Array
        //};

        var result = translate_graph_1to1(chcs["@graph"], is_chcsPerson, translate_demographics_fhir); // Array => Array
        var graph = result[0].map(function (g) {return g[0];});

        var participating_properties = result[0].reduce(
            function(previous, current) { return _.union(previous, current); },
            []);

        // See the result
        logger.debug(pretty_print(result[0]));
        logger.debug(participating_properties);
        var all_keys_in_graph = all_keys(chcs["@graph"]);
        logger.debug(_.difference(all_keys_in_graph, participating_properties));

        return result;

    } catch (err) {
        logger.error(err);
    }

}


/**
 * Read the chcs from stdin and process that.
 * @param {Readable Stream} s - usually stdin or something directed toward it.
 * @returns {(string|object)} -- turtle string or json fhir
 */
function process_stream(s) {
    logger.error("tbs");
}



/**
 * Exact the program version from package.json if you can find package.json
 * @param default_version
 * @returns {*}
 */
function get_version(default_version) {
    var result = default_version;
    try {
        result = load("../package.json").version;
    } finally {
        return result;
    }
}

// https://github.com/tj/commander.js/
program
    .version(get_version('0.0.1'))
    .option('-v, --verbose', 'verbose')
    .option('-h, --help', 'usage')
    .option('--level [level]', 'log level usage', 'DEBUG')
    .option('--log [log_file]', 'log file')
    .parse(process.argv);

logger.setLevel(program.level);


// TODO mcarifio: must be a way to just process these all as streams?
if (program.args.length > 0) {
    // process urls (files) from the command line
    program.args.forEach(process_file);
} else {
    // process stdin
    process_stream(process.stdin);
}














//------------------------------------------------------
// utility functions that need a home elsewhere

/**
 * Pretty print a JSON object.
 * @param json
 */

function pretty_print(json) {
    return JSON.stringify(json, null, 2);
}


// TODO: underscore? utility library?
function isList(o) { return o.constructor == Array; }

/**
 * Deep clone of input object o for any type. Protect against modification of object o.
 * @param {object} o - input object
 * @returns {object} - copy of o, same contents different memory
 */

function clone(o) {
    return JSON.parse(JSON.stringify(o));
}


/**
 * Slurp returns the contents of filename as a utf8 string.
 * @param {string} filename
 * @returns {string}
 *
 * TODO mike@carif.io: Does node|js have a pathname repr?
 */
function slurp(filename) {
    // TODO mike@carif.io: async this eventually
    // https://nodejs.org/api/fs.html#fs_fs_readfilesync_file_options
    return fs.readFileSync(filename, "utf8");
}




/**
 * Load a file and return it as a JSON object. Remove comments.
 * @param {string} filename
 * @returns {object} - JSON object from filename
 */

function load(filename) {
    var s = slurp(filename);
    var j = decomment(s);
    // logger.debug(j);
    return JSON.parse(j);
}
